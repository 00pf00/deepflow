/*
 * Copyright (c) 2012-2015 YunShan Networks, Inc.
 *
 * Author Name: Xiang Yang
 * Finish Date: 2015-11-24
 */

package DFI;
option java_package = "cn.net.yunshan.message";
option java_outer_classname = "DFIMessage";

message FlowHeader {
    required fixed64 sequence = 1; /* start from 1 */
}

message OvsPort {
    optional string mac = 1;
    optional uint32 dp_port = 2;
    optional string interface_name = 3;
    optional string bridge_name = 4;
}

message OvsTopology {
    repeated OvsPort ports = 1;
}

enum RequestType {
    FLOW_HEADER = 1;
    OVS_TOPOLOGY = 2;
    PACKET_HEADER = 3;
}

message Request {
    optional RequestType type = 1;
}

/*
 * Evaluated in host byte order.
 * If the value is the same as the default value, then the corresponding key
 * is unnecessary to be evaluated, in other words, has_xxx = 0
 */
message Flow {
    optional uint32 host = 1;         /* If exporter is in an Analyzer, host = exporter;
                                         elif exporter is in an Exporter, host = the hypervisor
                                         on which the data source of the Exporter resides */
    optional uint32 exporter = 2;     /* Control IP for exporter */
    optional uint32 close_type = 7;   /* 0=unknown, 1=tcp-fin, 2=tcp-rst, 3=timeout,
                                         4=toomany, 5=forced-report, 6=forced-close,
                                         7=half-timeout */
    optional uint64 flow_id = 8;      /* The forcefully reported flow is still kept in
                                         exporter and this tuple (host, thread_index, flow_id)
                                         can be used to identify the flow in poseidon */
    optional uint32 start_time = 11;  /* 1. First report: the time when the first packet arrives
                                         2. Latter reports: equals to end_time in last report */
    optional uint32 end_time = 12;    /* The time when exporter reports this flow */
    optional uint64 duration = 13;    /* 1. For flows !FIN && !RST, equals to
                                             end_time - time_of_the_first_packet_in_the_flow
                                         2. For others, equals to
                                             max(arr_time_0_last, arr_time_1_last) -
                                                 time_of_the_first_packet_in_the_flow */

    /* L1 */
    optional uint32 in_port_0 = 21 [default = 0];
    optional uint32 in_port_1 = 22 [default = 0];   /* Deprecated due to always equal to in_port_0 */

    /* L2 */
    optional uint32 vlan = 31 [default = 0];
    optional uint32 eth_type = 32 [default = 0];
    optional uint64 mac_src = 33 [default = 0];     /* 0x0000123456789abc == 12:34:56:78:9a:bc */
    optional uint64 mac_dst = 34 [default = 0];     /* 0x0000123456789abc == 12:34:56:78:9a:bc */

    /* L3 */
    optional uint32 ip_src = 41 [default = 0];      /* 0x01020304 == 1.2.3.4 */
    optional uint32 ip_dst = 42 [default = 0];      /* 0x01020304 == 1.2.3.4 */

    /* L4 */
    optional uint32 proto = 51 [default = 0];
    optional uint32 port_src = 52 [default = 0];
    optional uint32 port_dst = 53 [default = 0];
    optional uint32 tcp_flags_0 = 54 [default = 0];
    optional uint32 tcp_flags_1 = 55 [default = 0];
    optional uint32 tcp_syn_seq = 56 [default = 0];
    optional uint32 icmp_id = 57 [default = 0];

    /* Tunnel */
    optional uint64 tun_id = 61 [default = 0];      /* Tunnel index where the flow is encapped, i.e., vl2_id */
    optional uint32 tun_ip_src = 62 [default = 0];  /* Tunnel source vtep IP where the flow is encapped */
    optional uint32 tun_ip_dst = 63 [default = 0];  /* Tunnel destination vtep IP where the flow is encapped */
    optional uint64 tun_type = 64 [default = 0];    /* Tunnel type where the flow is encapped,
                                                       1=VXLAN, 2=NVGRE, 3=GENEVE */

    /* Overlay */
    optional uint64 overlay_tun_id = 66 [default = 0];    /* Overlay tunnel index of the flow */
    optional uint32 overlay_tun_type = 67 [default = 0];  /* Overlay tunnel type of the flow,
                                                             1=VXLAN, 2=NVGRE, 3=GENEVE */

    /* L7 */

    /* Packet Counters */
    optional uint64 byte_cnt_0 = 71 [default = 0];  /* Received byte cnt in this report period in
                                                       forward direction */
    optional uint64 byte_cnt_1 = 72 [default = 0];  /* Received byte cnt in this report period in
                                                       backward direction */
    optional uint64 pkt_cnt_0 = 73 [default = 0];   /* Received packet cnt in this report period in
                                                       forward direction */
    optional uint64 pkt_cnt_1 = 74 [default = 0];   /* Received packet cnt in this report period in
                                                       backward direction */
    optional uint64 total_byte_cnt_0 = 75 [default = 0]; /* Received byte cnt of this flow in
                                                            forward direction */
    optional uint64 total_byte_cnt_1 = 76 [default = 0]; /* Received byte cnt of this flow in
                                                            backward direction */
    optional uint64 total_pkt_cnt_0 = 77 [default = 0];  /* Received packet cnt of this flow in
                                                            forward direction */
    optional uint64 total_pkt_cnt_1 = 78 [default = 0];  /* Received packet cnt of this flow in
                                                            backward direction */

    /* Timers */
    optional uint64 cur_start_time = 81 [default = 0];   /* The arr_time of the first packet of
                                                            current report period, which is saved as
                                                            the start time of current report period
                                                            and will be used to calculate rate */
    optional uint64 arr_time_0_0 = 82 [default = 0];     /* The microseconds from 1970.1.1 to
                                                            the arriving time of the first packet of this
                                                            flow in forward direction */
    optional uint64 arr_time_0_last = 85 [default = 0];  /* The arriving offset of the last packet in
                                                            forward direction */
    optional uint64 arr_time_1_0 = 86 [default = 0];     /* The microseconds from 1970.1.1 to
                                                            the arriving time of the first packet of this
                                                            flow in backward direction */
    optional uint64 arr_time_1_last = 89 [default = 0];  /* The arriving offset of the last packet in
                                                            backward direction */

    /* Fragment Counters */
    optional uint64 frag_byte_cnt_0 = 91 [default = 0];  /* Received fragment byte cnt in this report period in
                                                            forward direction */
    optional uint64 frag_byte_cnt_1 = 92 [default = 0];  /* Received fragment byte cnt in this report period in
                                                            backward direction */
    optional uint64 frag_pkt_cnt_0 = 93 [default = 0];   /* Received fragment packet cnt in this report period in
                                                            forward direction */
    optional uint64 frag_pkt_cnt_1 = 94 [default = 0];   /* Received fragment packet cnt in this report period in
                                                           backward direction */
    optional uint64 total_frag_byte_cnt_0 = 95 [default = 0]; /* Received fragment byte cnt of this flow in
                                                                 forward direction */
    optional uint64 total_frag_byte_cnt_1 = 96 [default = 0]; /* Received fragment byte cnt of this flow in
                                                                 backward direction */
    optional uint64 total_frag_pkt_cnt_0 = 97 [default = 0];  /* Received fragment packet cnt of this flow in
                                                                 forward direction */
    optional uint64 total_frag_pkt_cnt_1 = 98 [default = 0];  /* Received fragment packet cnt of this flow in
                                                                 backward direction */

    /* Platform Data */
    optional uint32 subnet_id_0 = 100 [default = 0];          /* subnetid of mac_src, platform network ID */
    optional uint32 subnet_id_1 = 101 [default = 0];          /* subnetid of mac_dst, platform network ID */

    optional uint32 l3_device_type_0 = 102 [default = 0];     /* devicetype of ip_src, platform VM/VGW/TPD instance */
    optional uint32 l3_device_type_1 = 103 [default = 0];     /* devicetype of ip_dst, platform VM/VGW/TPD instance */
    optional uint32 l3_device_id_0 = 104 [default = 0];       /* deviceid of ip_src, platform instance ID */
    optional uint32 l3_device_id_1 = 105 [default = 0];       /* deviceid of ip_dst, platform instance ID */
    optional uint32 l3_epc_id_0 = 106 [default = 0];          /* epc_id of device of ip_src, platform project ID */
    optional uint32 l3_epc_id_1 = 107 [default = 0];          /* epc_id of device of ip_dst, platform project ID */

    optional uint32 epc_id_0 = 120 [default = 0];             /* epc_id of device of mac_src, platform project ID */
    optional uint32 epc_id_1 = 121 [default = 0];             /* epc_id of device of mac_dst, platform project ID */
    optional uint32 device_type_0 = 122 [default = 0];        /* devicetype of mac_src, platform VM/VGW/TPD instance */
    optional uint32 device_type_1 = 123 [default = 0];        /* devicetype of mac_dst, platform VM/VGW/TPD instance */
    optional uint32 device_id_0 = 124 [default = 0];          /* deviceid of mac_src, platform instance ID */
    optional uint32 device_id_1 = 125 [default = 0];          /* deviceid of mac_dst, platform instance ID */
    optional uint32 if_index_0 = 126 [default = 0];           /* ifindex of mac_src, platform instance NIC index */
    optional uint32 if_index_1 = 127 [default = 0];           /* ifindex of mac_dst, platform instance NIC index */
    optional uint32 if_type_0 = 128 [default = 0];            /* iftype of mac_src, platform instance WAN/LAN/Ctrl NIC */
    optional uint32 if_type_1 = 129 [default = 0];            /* iftype of mac_dst, platform instance WAN/LAN/Ctrl NIC */

    optional bool is_l2_end_0 = 130 [default = false];        /* 网流mac_src对应的实例和网流被采集的Exporter是否在同一宿主机上 */
    optional bool is_l2_end_1 = 131 [default = false];        /* 网流mac_dst对应的实例和网流被采集的Exporter是否在同一宿主机上 */
    optional bool is_l3_end_0 = 132 [default = false];        /* 网流mac_src和ip_src对应的同一实例和网流被采集的Exporter是否在同一宿主机上 */
    optional bool is_l3_end_1 = 133 [default = false];        /* 网流mac_dst和ip_dst对应的同一实例和网流被采集的Exporter是否在同一宿主机上 */

    repeated uint32 group_ids_0 = 134;                         /* 源端资源组ID */
    repeated uint32 group_ids_1 = 135;                         /* 目的端资源组ID */
    repeated uint32 whitelist_rule_ids_0 = 136;                /* 源端资源组Id匹配的白名单策略ID */
    repeated uint32 whitelist_rule_ids_1 = 137;                /* 目的端资源组Id匹配的白名单策略ID */
    repeated uint32 custom_tag_ids_0 = 138;                    /* 源端客户自定义标签ID */
    repeated uint32 custom_tag_ids_1 = 139;                    /* 目的端客户自定义标签ID */

    /* TCP Perf Data */
    optional uint64 rtt_syn = 140 [default = 0];               /* The RTT in the handshake phase of the flow.
                                                                  When pkt_cnt_0 >= 2 && pkt_cnt_1 >= 1,
                                                                  SYN -> SYN/ACK -> ACK,
                                                                  rtt_syn = arr_time_0_1 (ACK) - arr_time_0_0 (SYN) */
    optional uint64 rtt = 141 [default = 0];                   /* The RTT in the data transmission phase of the flow
                                                                  it's a average value in this report period
                                                                  ... PSH/ACK_n-1 -> PSH/ACK_n -> ACK_n -> PSH/ACK_n+1 -> PSH/ACK_n+2 ...,
                                                                  rtt_Nth = tx_time_1 (PSH/ACK_n+1) - tx_time_0 (PSH/ACK_n),
                                                                  rtt = (rtt_1st + rtt_2nd + ... + rtt_Nth) / N, or
                                                                  rtt = (rtt * (N - 1) + rtt_Nth) / N */
    optional uint64 rtt_avg = 142 [default = 0];               /* The RTT in the session of the flow
                                                                  it's a average value in flow life cycle */
    optional uint64 syn_retrans_cnt_0 = 143 [default = 0];     /* Times of packets retransmission within connection establishment during this report period
                                                                  in forward direction */
    optional uint64 syn_retrans_cnt_1 = 144 [default = 0];     /* Times of packets retransmission within connection establishment during this report period
                                                                  in backword direction */
    optional uint64 retrans_cnt_0 = 145 [default = 0];         /* Times of packets retransmission during this report period
                                                                  in forward direction */
    optional uint64 retrans_cnt_1 = 146 [default = 0];         /* Times of packets retransmission during this report period
                                                                  in backword direction */
    optional uint64 total_retrans_cnt = 147 [default = 0];     /* Times of packets retransmission in flow life cycle
                                                                  including forward and backword direction */
    optional uint64 zero_wnd_cnt_0 = 148 [default = 0];        /* Times of TCP connection window is set to zero in forward direction
                                                                  during this report period */
    optional uint64 zero_wnd_cnt_1 = 149 [default = 0];        /* Times of TCP connection window is set to zero in backward direction
                                                                  during this report period */
    optional uint64 total_zero_wnd_cnt = 150 [default = 0];    /* Times of TCP connection window is set to zero in flow life cycle
                                                                  including forward and backword direction */
    optional uint64 slow_start_cnt_0 = 151 [default = 0];      /* Times of TCP connection slow start in forward direction
                                                                  during this report period */
    optional uint64 slow_start_cnt_1 = 152 [default = 0];      /* Times of TCP connection slow start in backward direction
                                                                  during this report period */
    optional uint64 total_slow_start_cnt = 153 [default = 0];  /* Times of TCP connection slow start in flow life cycle
                                                                  including forward and backward direction */
    optional uint64 psh_urg_cnt_0 = 154 [default = 0];         /* Times of TCP connection sending urgent data in forward direction
                                                                  during this report period */
    optional uint64 psh_urg_cnt_1 = 155 [default = 0];         /* Times of TCP connection sending urgent data in backward direction
                                                                  during this report period */
    optional uint64 total_psh_urg_cnt = 156 [default = 0];     /* Times of TCP connection sending urgent data in flow life cycle
                                                                  including forward and backward direction */
}

/* 注意：message中的tag不要大于31，大于31以后key会多占用1个字节。
 *    1. 字段delta_key表示记录该key和前一个包的该key的值的差量
 *       假定所有差量都可能为负数，使用sint，当差值为0时不用记录
 *    2. 字段key为null（has_key=0）表示该key和前一个包的该key的值相同
 *    3. 字段key不为null（has_key=1）表示记录原始值
 *    4. 每条网流的首包要记录所有key和delta_key
 */
message EthernetHeader {
    optional uint64 destination_address = 1;          //    6 B
    optional uint64 source_address = 2;               //    6 B
    optional uint32 ether_type = 3;                   //    2 B
    optional uint32 vlan_tag = 4;                     //    4 B
}

message Ipv4Header {
    optional uint32 version = 1;                      //  1/2 B
    optional uint32 ihl = 2;                          //  1/2 B
    optional uint32 tos = 3;                          //    1 B
    optional uint32 total_length = 4;                 //    2 B
    optional sint32 delta_identification = 5;         //    2 B
    // flags is combined into fragment offset
    optional sint32 delta_fragment_offset = 6;        //    2 B
    optional uint32 ttl = 7;                          //    1 B
    optional uint32 protocol = 8;                     //    1 B
    // ignore check_sum if it is correct
    optional uint32 header_checksum = 9;              //    2 B
    // IP address always has 4B, use fixed encoding
    optional fixed32 source_address = 10;             //    4 B
    optional fixed32 destination_address = 11;        //    4 B

    // 5.0不考虑IP option的压缩，直接将byte数组放在此处即可
    // options基本由byte组成，从wiki来看也没有压缩空间：
    // https://en.wikipedia.org/wiki/IPv4
    optional bytes options = 12;                      // 0-40 B
}

message TcpHeader {
    optional uint32 source_port = 1;                  //    2 B
    optional uint32 destination_port = 2;             //    2 B
    optional sint64 delta_sequence_number = 3;        //    4 B
    optional sint64 delta_acknowledgement_number = 4; //    4 B
    optional uint32 data_offset = 5;                  //  1/2 B
    optional uint32 reserved = 6;                     //  1/2 B
    optional uint32 flags = 7;                        //    1 B
    optional sint32 delta_window = 8;                 //    2 B
    // checksum is ignored here                             2 B
    optional uint32 urgent_pointer = 9;               //    2 B

    // TCP option很常见的，由byte、u16、u32组成，且存在很多不确定性
    // 5.0考虑将TCP options分割成10个4字节word，仅记录差量
    // https://en.wikipedia.org/wiki/Transmission_Control_Protocol
    optional sint64 delta_option_0w = 10;             //    4 B
    optional sint64 delta_option_1w = 11;             //    4 B
    optional sint64 delta_option_2w = 12;             //    4 B
    optional sint64 delta_option_3w = 13;             //    4 B
    optional sint64 delta_option_4w = 14;             //    4 B
    optional sint64 delta_option_5w = 15;             //    4 B
    optional sint64 delta_option_6w = 16;             //    4 B
    optional sint64 delta_option_7w = 17;             //    4 B
    optional sint64 delta_option_8w = 18;             //    4 B
    optional sint64 delta_option_9w = 19;             //    4 B
}

message UdpHeader {
    optional uint32 source_port = 1;                  //    2 B
    optional uint32 destination_port = 2;             //    2 B
    optional uint32 length = 3;                       //    2 B
    // checksum is ignored here                             2 B
}

message PacketHeader {
    optional sint64 delta_timestamp = 1;  // microseconds,  8 B
    optional EthernetHeader ethernet = 2; // L2 header, 14-18 B
    optional Ipv4Header ipv4 = 3;         // L3 header, 20-60 B
    optional TcpHeader tcp = 4;           // L4 header, 18-58 B
    optional UdpHeader udp = 5;           // L4 header,     6 B
}

enum Direction
{
    FORWARD = 0; // 正向，发起请求的流方向
    REVERSE = 1; // 反向，回复请求的流方向
}

/* protobuf-message format */
message FlowPktHdrBatch {
    optional uint32 host = 1;       // DFI所在节点的本地IP，无需填写，由控制器推断
    optional uint64 flow_id = 2;
    optional Direction direction = 3 [default = FORWARD];
    optional uint32 sequence = 4;

    // 连续多个PacketHeader序列化（压缩）以后的字节数组，最大长度为BUFFER_SIZE
    // 内存排布：header_0, ..., header_i, ..., header_n, 0xFF结束标记
    //   header_i排布：compressed_header_size_i(1B), compressed_header_i
    optional bytes compressed_headers = 5;
    optional uint32 close_type = 6;
    optional uint32 exporter = 7;
}
